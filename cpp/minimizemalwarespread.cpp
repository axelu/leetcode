
// 924. Minimize Malware Spread
// https://leetcode.com/problems/minimize-malware-spread/





class Solution {
private:

    // binary search
    bool search(vector<int>& v, int s, int e, int k) {
        if( s > e ) return false;

        int mid = s + ((e-s)/2);
        if( v[mid] == k ) {
            return true;
        } else if( v[mid] < k ) {
            return search(v,mid+1,e,k);
        } else {
            return search(v,s,mid-1,k);
        }
    }

    void dfs(vector<vector<int>>& graph, int n, int u, vector<int>& initial, int m,
             int& size, bool& isOnly, int seen[]) {

        seen[u] = 1;

        for(int i = 0; i < n; ++i) {
            if( u == i )
                continue;

            if( graph[u][i] == 0 )
                continue;

            if( seen[i] )
                continue;

            if( isOnly )
                isOnly = !search(initial,0,m-1,i);

            ++size;

            dfs(graph,n,i,initial,m,size,isOnly,seen);
        }
    }

public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // vector<vector<int>>& graph adjacency matrix

        int n = graph.size();
        int seen[n];memset(seen,0,sizeof seen);

        // running DFS to get all nodes connected to an infected node
        // we will keep track of the size of the connected component
        // and if the infected node we started from is the only infected
        // node in the connected component
        // if there is more more than one infected node in the component,
        // then there is no point in removing any of them
        sort(initial.begin(),initial.end()); // we are asked to return minimal node
                                             // it will also allow us to search

        int mxComponent = 0;
        int ans = -1;

        int m = initial.size();
        for(int i = 0; i < m; ++i) {

            if( !seen[initial[i]] ) {
                int t = 1;
                bool isOnly = true;
                dfs(graph,n,initial[i],initial,m,t,isOnly,seen);

                if( isOnly ) {
                    // our node is the only infected node in the connected component
                    if( t > mxComponent ) {
                        // our connected component is larger than any other
                        // connected component so far encountered
                        mxComponent = t;
                        ans = initial[i];
                    }
                }
            }
        }

        return ans == -1 ? initial[0] : ans;
    }
};
