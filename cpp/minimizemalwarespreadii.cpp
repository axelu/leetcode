
// 928. Minimize Malware Spread II
// https://leetcode.com/problems/minimize-malware-spread-ii/






// https://www.thealgorists.com/Algo/GraphTheory/Tarjan/Bridges
// Finding Bridges in a Connected Undirected Graph using Tarjan's Algorithm
// see https://leetcode.com/problems/critical-connections-in-a-network/
class Solution {
private:
    int dfs(vector<vector<int>>& graph, int n, int seen[], int count[], int infected[],
             int u, int discoveryTimes[], int low[], int parent[], int& discoveryTime) {
        // returns the number of nodes that could be safed behind a bridge
        // if there is an infection behind a bridge, returns 0

        seen[u] = 1;
        bool isInfected = infected[u];

        ++discoveryTime;  // increment discovery time before assigning
        discoveryTimes[u] = discoveryTime;
        low[u] = discoveryTime;

        int cnt = 1; // number of nodes that could be saved

        int t;
        for(int v = 0; v < n; ++v) { // adjacent node
            if( u == v )
                continue;

            if( graph[u][v] == 0 )
                continue;

            if( !seen[v]) {
                // the adjacent node is NOT an ancestor
                parent[v] = u;
                t = dfs(graph,n,seen,count,infected,v,discoveryTimes,low,parent,discoveryTime);
                if( t == 0 )
                    isInfected = true;
                else
                    cnt += t;

                if( low[v] >= discoveryTimes[u]) { // bridge found
                        count[u] += t;
                }

                low[u] = min(low[u],low[v]);
            } else {
                // the adjacent node is an ancestor
                if( parent[u] != v) {
                    // the adjacent node is NOT the parent
                    low[u] = min(low[u],discoveryTimes[v]);
                }
            }
        }

        return isInfected ? 0 : cnt;
    }

public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        // vector<vector<int>>& graph adjacency matrix

        int n = graph.size();
        int seen[n];memset(seen,0,sizeof seen);

        // mark infected nodes
        int infected[n];memset(infected,0,sizeof infected);
        int m = initial.size();
        for(int i = 0; i < m; ++i)
            infected[initial[i]] = 1;


        int mxComponent = 0; // better: max number of nodes that could be saved
        int ans = initial[0];


        int discoveryTimes[n];
        int low[n]; // earliest discovered node reachable from node at idx
                    //     by not using backedge that goes through parent
        int parent[n];

        int count[n];memset(count,0,sizeof count); // number of nodes that could be saved by removing node u
        int u;
        for(int i = 0; i < m; ++i) {
            u = initial[i];

            if( !seen[u] ) {
                int discoveryTime = -1;
                dfs(graph,n,seen,count,infected,u,discoveryTimes,low,parent,discoveryTime);
            }

            if( count[u] > mxComponent || (count[u] == mxComponent && u < ans) )  {
                mxComponent = count[u];
                ans = u;
            }

        }

        return ans;
    }
};
